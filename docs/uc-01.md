### **Use Case Specification: Run GoodAI LTM Benchmark Test (Corrected Version)**

| **Use Case Name:** | Execute a Single Test from the GoodAI LTM Benchmark |
| :--- | :--- |
| **ID:** | UC-01 |
| **Actors:** | Benchmark Runner (Script), **MAS (Full System)**, `PlannerAgent`, `ConsolidationAgent`, **UnifiedMemorySystem** |
| **Description:** | The system processes a single turn from a long-running conversational test within the GoodAI LTM Benchmark. This demonstrates the system's ability to retrieve relevant information from a long, noisy history, synthesize it with the current context, generate a correct response, and update its memory state for future turns. |
| **Preconditions:** | 1. The full MAS, including the Asymmetric "Orchestrator/Data Node" infrastructure, is deployed and all services (Redis, Qdrant, Neo4j, Typesense, PostgreSQL) are running and accessible. <br> 2. The `UnifiedMemorySystem` is instantiated with the "Full System" configuration, connecting it to all live backend services. <br> 3. An "Agent Wrapper" API endpoint is running on the Orchestrator Node, ready to receive requests from the benchmark script. <br> 4. The GoodAI LTM Benchmark dataset and runner script are available. |
| **Postconditions:** | 1. The agent's final answer is returned to the Benchmark Runner for scoring. <br> 2. The state of the Operating Memory (L1/L2) and potentially the Persistent Knowledge Layer (L3) is updated. <br> 3. Detailed instrumentation logs for the entire transaction are written to the observability store (e.g., Arize Phoenix via PostgreSQL) for later analysis. |

---

| **Step** | **Action Description & Component Interaction** | **Requirements for this Step** |
| :--- | :--- | :--- |
| 1. **Initiation** | The **Benchmark Runner** script sends an HTTP request to the Agent Wrapper. The request payload contains the full conversational history and the latest user message. | - Agent Wrapper must expose a stable, well-defined API endpoint (e.g., `/run_turn`). <br> - Wrapper must correctly parse the benchmark's JSON payload format. |
| 2. **Task Delegation** | The Agent Wrapper forwards the request to the primary reasoning agent within the MAS, the **`PlannerAgent`**. The `PlannerAgent` is tasked with generating a correct response. | - The MAS must have a defined routing mechanism to assign incoming tasks. <br> - The `PlannerAgent` must be instantiated and in a ready state to accept tasks. |
| 3. **Internal State Retrieval (L1/L2)** | The **`PlannerAgent`** calls `memory.get_personal_state()`. The **`UnifiedMemorySystem`** handles this by retrieving the agent's `PersonalMemoryState` object from the **Operating Memory (Redis)** on the local Orchestrator Node. | - `UnifiedMemorySystem` must have a live connection to the Redis client. <br> - **Performance:** This local Redis GET operation must have sub-millisecond latency (<0.1ms). |
| 4. **Tiered Knowledge Retrieval (L3)** | The **`PlannerAgent`** determines it needs long-term knowledge. It calls `memory.query_knowledge()` (e.g., for 'vector' and 'graph'). The **`UnifiedMemorySystem`** delegates these calls to the **`KnowledgeStoreManager`**, which makes **network calls** to the Data Node to query the **Persistent Knowledge Layer**. | - `PlannerAgent` logic must be capable of formulating effective retrieval queries. <br> - A stable, low-latency network connection must exist between the Orchestrator and Data nodes. <br> - L3 databases (Qdrant, Neo4j) must be running, indexed, and capable of serving queries with acceptable network latency (target <50ms). |
| 5. **Synthesis & Response Generation** | The **`PlannerAgent`** receives the retrieved knowledge chunks. It synthesizes this context with the conversational history and its own state, assembles a final prompt, and calls the LLM to generate a response. | - **Agent Capability:** The agent's prompt template must be robust enough to synthesize information from multiple, potentially conflicting sources. <br> - The total assembled context must not exceed the LLM's context window limit. |
| 6. **Update Working Memory (L1/L2)** | The **`PlannerAgent`** updates its `PersonalMemoryState` object (e.g., updating its `scratchpad`). It then calls `memory.update_personal_state()`. The **`UnifiedMemorySystem`** serializes and writes this new state back to the **Operating Memory (Redis)**. | - **Performance:** This local Redis SET operation must have sub-millisecond latency. <br> - The state object must be serializable to JSON. |
| 7. **Asynchronous Consolidation (L3)** | A background **`ConsolidationAgent`** is triggered. It reads the updated `PersonalMemoryState`, applies its EPDL/Consolidation logic, and if necessary, calls the **`KnowledgeStoreManager`** to write updated knowledge to the **Persistent Knowledge Layer** on the Data Node. | - **Architectural:** This process **must** run asynchronously or with low priority to avoid blocking the main reasoning loop of the `PlannerAgent`. <br> - **Agent Capability:** The `ConsolidationAgent` must have a clearly defined logic for deciding whether to ADD, UPDATE, or NO-OP on a piece of knowledge. |
| 8. **Finalization** | The **`PlannerAgent`** returns its final generated text response to the Agent Wrapper, which sends it back to the **Benchmark Runner** via the HTTP response. | - The response format must strictly adhere to the schema expected by the benchmark's scoring script. |