
### **Use Case Specification: Run GoodAI LTM Benchmark with Standard RAG Agent**

| **Use Case Name:** | Execute a Single Test from the GoodAI LTM Benchmark (Standard RAG Baseline) |
| :--- | :--- |
| **ID:** | UC-02 |
| **Actors:** | Benchmark Runner (Script), **MAS (Standard RAG Baseline)**, `RAGAgent`, **UnifiedMemorySystem** |
| **Description:** | The system processes a single turn from the GoodAI LTM Benchmark using a conventional, single-layer RAG agent. This baseline serves as a direct comparison to evaluate the performance gains of the full hybrid memory architecture. The agent is stateless and relies on a single vector store for all memory operations. |
| **Preconditions:** | 1. The infrastructure is deployed. A single vector store (Qdrant) is available on the Data Node to act as the sole memory layer. <br> 2. The `UnifiedMemorySystem` is instantiated with the "Standard RAG" configuration. In this mode, it bypasses all Operating Memory and Consolidation logic, routing all queries directly to the single Qdrant collection. <br> 3. The Agent Wrapper API endpoint is running. <br> 4. For each test, the *entire* conversational history is pre-loaded and indexed into the Qdrant collection. |
| **Postconditions:** | 1. The agent's final answer is returned to the Benchmark Runner for scoring. <br> 2. The state of the single vector store is updated with the new conversational turn. <br> 3. Instrumentation logs for the transaction are written to the observability store. |

---

| **Step** | **Action Description & Component Interaction** | **Requirements for this Step** |
| :--- | :--- | :--- |
| 1. **Initiation** | The **Benchmark Runner** sends an HTTP request to the Agent Wrapper with the full history and the latest user message. | - Agent Wrapper must expose the same API endpoint (`/run_turn`) as UC-01. <br> - Wrapper must correctly parse the benchmark's JSON payload. |
| 2. **Task Delegation** | The Agent Wrapper forwards the request to the `RAGAgent`. | - The MAS is configured to route all incoming tasks directly to the `RAGAgent`. |
| 3. **Internal State Retrieval** | The **`RAGAgent`** performs **no action** to retrieve internal state. By design, this baseline is stateless and begins each turn with a blank slate. | - **Architectural Constraint:** The agent's logic must *not* depend on any persistent internal state between turns (i.e., no concept of a Personal Scratchpad). |
| 4. **Knowledge Retrieval** | The **`RAGAgent`** executes a simple, single-pass retrieval strategy: <br> a) It takes the latest user message as the query. <br> b) It calls `memory.query_knowledge(store_type='vector', ...)` once. <br> c) The **`UnifiedMemorySystem`** (in its baseline configuration) makes a **network call** to the Data Node to perform a semantic search against the single **Qdrant** collection containing the entire history. | - The Qdrant collection must be pre-indexed with the full conversational history for each test. <br> - **Performance:** This single, large query is expected to have higher latency than the L2 cache lookups in the Full System, as it must search over a much larger and potentially noisier dataset. |
| 5. **Synthesis & Response Generation** | The **`RAGAgent`** receives the retrieved text chunks. It synthesizes this context with the latest user message, assembles a prompt, and calls the LLM to generate a response. | - **Agent Capability:** The agent's prompt engineering must be robust enough to handle potentially noisy or less relevant retrieved chunks from the single-pass retrieval. |
| 6. **Update Working Memory** | The **`RAGAgent`** performs **no action** to update a working memory. It does not maintain any transient state after the response is generated. | - **Architectural Constraint:** The system is intentionally configured without an L1/L2 Operating Memory layer for the agent to write to. |
| 7. **Asynchronous Consolidation** | This step is **not applicable** for the Standard RAG baseline. The new conversational turn (user message + AI response) is simply appended and re-indexed into the single Qdrant collection for the next turn. | - **Architectural Constraint:** The system has no concept of a multi-layered memory or an intelligent consolidation process. New data is added indiscriminately. |
| 8. **Finalization** | The **`RAGAgent`** returns its final generated text response to the Agent Wrapper, which sends it back to the **Benchmark Runner**. | - The response format must strictly adhere to the schema expected by the benchmark's scoring script. |